diff --git a/src/main/java/com/orasa/backend/config/AppConfig.java b/src/main/java/com/orasa/backend/config/AppConfig.java
index bb902e9..12e7a36 100644
--- a/src/main/java/com/orasa/backend/config/AppConfig.java
+++ b/src/main/java/com/orasa/backend/config/AppConfig.java
@@ -2,25 +2,31 @@ package com.orasa.backend.config;
 
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.http.client.SimpleClientHttpRequestFactory;
 import org.springframework.web.client.RestTemplate;
 
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.SerializationFeature;
+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
+
 @Configuration
 public class AppConfig {
 
     @Bean
     public RestTemplate restTemplate() {
-        org.springframework.http.client.SimpleClientHttpRequestFactory factory = new org.springframework.http.client.SimpleClientHttpRequestFactory();
+        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
         factory.setConnectTimeout(30000);
         factory.setReadTimeout(30000);
         return new RestTemplate(factory);
     }
 
     @Bean
-    public com.fasterxml.jackson.databind.ObjectMapper objectMapper() {
-        com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
-        mapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
-        mapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
-        mapper.disable(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); // Flexible for frontend changes
+    public ObjectMapper objectMapper() {
+        ObjectMapper mapper = new ObjectMapper();
+        mapper.registerModule(new JavaTimeModule());
+        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
+        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
         return mapper;
     }
 }
diff --git a/src/main/java/com/orasa/backend/config/CacheConfig.java b/src/main/java/com/orasa/backend/config/CacheConfig.java
index ca35a2d..fd9630a 100644
--- a/src/main/java/com/orasa/backend/config/CacheConfig.java
+++ b/src/main/java/com/orasa/backend/config/CacheConfig.java
@@ -2,6 +2,8 @@ package com.orasa.backend.config;
 
 import java.time.Duration;
 
+import org.springframework.cache.CacheManager;
+import org.springframework.cache.annotation.CachingConfigurer;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.data.redis.cache.RedisCacheConfiguration;
@@ -16,12 +18,18 @@ import com.fasterxml.jackson.databind.SerializationFeature;
 import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
 import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
 
+import lombok.RequiredArgsConstructor;
+
 @Configuration
-public class CacheConfig {
+@RequiredArgsConstructor
+public class CacheConfig implements CachingConfigurer {
+
+    private final RedisConnectionFactory connectionFactory;
 
     @SuppressWarnings({"removal", "deprecation"})
     @Bean
-    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
+    @Override
+    public CacheManager cacheManager() {
         ObjectMapper objectMapper = new ObjectMapper();
         objectMapper.registerModule(new JavaTimeModule());
         objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
@@ -46,4 +54,3 @@ public class CacheConfig {
                 .build();
     }
 }
-
diff --git a/src/main/java/com/orasa/backend/service/ActivityLogService.java b/src/main/java/com/orasa/backend/service/ActivityLogService.java
index d7760e6..068ecc0 100644
--- a/src/main/java/com/orasa/backend/service/ActivityLogService.java
+++ b/src/main/java/com/orasa/backend/service/ActivityLogService.java
@@ -5,9 +5,9 @@ import java.time.OffsetDateTime;
 import java.time.format.DateTimeFormatter;
 import java.util.UUID;
 
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.cache.annotation.Cacheable;
-import org.springframework.cache.annotation.Caching;
+
+import com.orasa.backend.common.CacheName;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.stereotype.Service;
@@ -33,6 +33,7 @@ import lombok.extern.slf4j.Slf4j;
 public class ActivityLogService {
     
     private final ActivityLogRepository activityLogRepository;
+    private final CacheService cacheService;
     
     private static final DateTimeFormatter DATE_TIME_FORMATTER =  
             DateTimeFormatter.ofPattern("MMM d, yyyy h:mm a");
@@ -53,10 +54,6 @@ public class ActivityLogService {
      * General-purpose logging method with details for expandable view.
      */
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "business-activity-logs", key = "#business.id"),
-        @CacheEvict(value = "branch-activity-logs", key = "#branch.id", condition = "#branch != null")
-    })
     public void logAction(UserEntity user, BusinessEntity business, BranchEntity branch, 
                           ActivityAction action, String description, String details) {
         try {
@@ -71,6 +68,10 @@ public class ActivityLogService {
             
             activityLogRepository.save(activityLog);
             log.debug("Logged action: {} by user {} - {}", action, user.getId(), description);
+            cacheService.evict(CacheName.BUSINESS_ACTIVITY_LOGS, business.getId());
+            if (branch != null) {
+                cacheService.evict(CacheName.BRANCH_ACTIVITY_LOGS, branch.getId());
+            }
         } catch (Exception e) {
             log.error("Failed to log activity: {} - {}", action, e.getMessage());
             // Activity logging should never break the main flow
@@ -241,7 +242,7 @@ public class ActivityLogService {
     // ==================== QUERY METHODS ====================
     
     @Transactional(readOnly = true)
-    @Cacheable(value = "business-activity-logs", key = "#businessId", condition = "#pageable.pageNumber == 0")
+    @Cacheable(value = CacheName.BUSINESS_ACTIVITY_LOGS, key = "#businessId", condition = "#pageable.pageNumber == 0")
     public PageResponse<ActivityLogResponse> getActivityLogsByBusiness(UUID businessId, Pageable pageable) {
         Page<ActivityLogResponse> page = activityLogRepository.findByBusinessIdOrderByCreatedAtDesc(businessId, pageable)
                 .map(this::mapToResponse);
@@ -249,7 +250,7 @@ public class ActivityLogService {
     }
     
     @Transactional(readOnly = true)
-    @Cacheable(value = "branch-activity-logs", key = "#branchId", condition = "#pageable.pageNumber == 0")
+    @Cacheable(value = CacheName.BRANCH_ACTIVITY_LOGS, key = "#branchId", condition = "#pageable.pageNumber == 0")
     public PageResponse<ActivityLogResponse> getActivityLogsByBranch(UUID branchId, Pageable pageable) {
         Page<ActivityLogResponse> page = activityLogRepository.findByBranchIdOrderByCreatedAtDesc(branchId, pageable)
                 .map(this::mapToResponse);
diff --git a/src/main/java/com/orasa/backend/service/AnalyticsService.java b/src/main/java/com/orasa/backend/service/AnalyticsService.java
index 3806c1c..a026061 100644
--- a/src/main/java/com/orasa/backend/service/AnalyticsService.java
+++ b/src/main/java/com/orasa/backend/service/AnalyticsService.java
@@ -9,6 +9,7 @@ import com.orasa.backend.dto.analytics.ServiceStatsDTO;
 import com.orasa.backend.dto.analytics.StatusStatsDTO;
 import java.util.List;
 import org.springframework.cache.annotation.Cacheable;
+import com.orasa.backend.common.CacheName;
 import com.orasa.backend.repository.AppointmentRepository;
 import com.orasa.backend.repository.SmsLogRepository;
 import lombok.RequiredArgsConstructor;
@@ -30,7 +31,7 @@ public class AnalyticsService {
     private final SmsLogRepository smsLogRepository;
     private final Clock clock;
 
-    @Cacheable(value = "analytics", key = "{#businessId, #branchId, #startDate, #endDate}")
+    @Cacheable(value = CacheName.ANALYTICS, key = "{#businessId, #branchId, #startDate, #endDate}")
     public DashboardStats getDashboardStats(UUID businessId, UUID branchId, LocalDate startDate, LocalDate endDate) {
         ZoneId zoneId = clock.getZone();
         OffsetDateTime start = startDate.atStartOfDay(zoneId).toOffsetDateTime();
diff --git a/src/main/java/com/orasa/backend/service/AppointmentService.java b/src/main/java/com/orasa/backend/service/AppointmentService.java
index de453bc..ee71a93 100644
--- a/src/main/java/com/orasa/backend/service/AppointmentService.java
+++ b/src/main/java/com/orasa/backend/service/AppointmentService.java
@@ -10,7 +10,7 @@ import java.util.List;
 import java.util.UUID;
 import java.util.Set;
 
-import org.springframework.cache.annotation.CacheEvict;
+
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.stereotype.Service;
@@ -45,6 +45,8 @@ import com.orasa.backend.domain.BusinessReminderConfigEntity;
 import com.orasa.backend.service.sms.SmsService;
 import com.orasa.backend.config.TimeConfig;
 
+import com.orasa.backend.common.CacheName;
+
 import lombok.RequiredArgsConstructor;
 
 @Service
@@ -61,9 +63,9 @@ public class AppointmentService {
   private final ServiceRepository serviceRepository;
   private final BusinessReminderConfigRepository reminderConfigRepository;
   private final Clock clock;
+  private final CacheService cacheService;
 
   @Transactional
-  @CacheEvict(value = "analytics", allEntries = true)
   public AppointmentResponse createAppointment(UUID userId, CreateAppointmentRequest request) {
     UserEntity user = userRepository.findById(userId)
         .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -147,11 +149,11 @@ public class AppointmentService {
         }
     }
 
+    cacheService.evictAll(CacheName.ANALYTICS);
     return mapToResponse(saved);
   }
 
   @Transactional
-  @CacheEvict(value = "analytics", allEntries = true)
   public UpdateResult updateAppointment(UUID userId, UUID id, UpdateAppointmentRequest request) {
     UserEntity user = userRepository.findById(userId)
         .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -369,11 +371,11 @@ public class AppointmentService {
         smsService.scheduleRemindersForAppointment(saved);
     }
 
+    cacheService.evictAll(CacheName.ANALYTICS);
     return new UpdateResult(mapToResponse(saved), true);
   }
 
   @Transactional
-  @CacheEvict(value = "analytics", allEntries = true)
   public AppointmentResponse updateAppointmentStatus(UUID userId, UUID id, AppointmentStatus newStatus) {
     UserEntity user = userRepository.findById(userId)
         .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -417,6 +419,7 @@ public class AppointmentService {
         }
     }
 
+    cacheService.evictAll(CacheName.ANALYTICS);
     return mapToResponse(saved);
   }
 
@@ -534,7 +537,6 @@ public class AppointmentService {
   }
 
   @Transactional
-  @CacheEvict(value = "analytics", allEntries = true)
   public void deleteAppointment(UUID userId, UUID id) {
     UserEntity user = userRepository.findById(userId)
         .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -557,6 +559,7 @@ public class AppointmentService {
     smsService.cancelRemindersForAppointment(id);
 
     appointmentRepository.delete(appointment);
+    cacheService.evictAll(CacheName.ANALYTICS);
   }
 
   // Helper methods
diff --git a/src/main/java/com/orasa/backend/service/BranchService.java b/src/main/java/com/orasa/backend/service/BranchService.java
index 06e58d0..fac0bcb 100644
--- a/src/main/java/com/orasa/backend/service/BranchService.java
+++ b/src/main/java/com/orasa/backend/service/BranchService.java
@@ -6,10 +6,10 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.cache.annotation.Cacheable;
-import org.springframework.cache.annotation.Caching;
 import org.springframework.stereotype.Service;
+
+import com.orasa.backend.common.CacheName;
 import org.springframework.transaction.annotation.Transactional;
 
 import com.orasa.backend.common.UserRole;
@@ -47,12 +47,9 @@ public class BranchService {
     private final ActivityLogService activityLogService;
     private final ServiceRepository serviceRepository;
     private final BranchServiceRepository branchServiceRepository;
+    private final CacheService cacheService;
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "branches", key = "#businessId"),
-        @CacheEvict(value = "user-branches", allEntries = true)
-    })
     public BranchResponse createBranch(UUID ownerId, UUID businessId, CreateBranchRequest request) {
         log.info("Creating new branch '{}' for business {}", request.getName(), businessId);
         UserEntity owner = userRepository.findById(ownerId)
@@ -96,10 +93,12 @@ public class BranchService {
         activityLogService.logBranchCreated(owner, business, saved);
 
         log.info("Branch created with ID: {}", saved.getId());
+        cacheService.evict(CacheName.BRANCHES, businessId);
+        cacheService.evictAll(CacheName.USER_BRANCHES);
         return mapToResponse(saved);
     }
 
-    @Cacheable(value = "branches", key = "#businessId")
+    @Cacheable(value = CacheName.BRANCHES, key = "#businessId")
     public List<BranchResponse> getBranchesByBusiness(UUID businessId) {
         List<BranchEntity> branches = branchRepository.findByBusinessId(businessId);
         return branches.stream()
@@ -107,7 +106,7 @@ public class BranchService {
                 .toList();
     }
 
-    @Cacheable(value = "user-branches", key = "#userId")
+    @Cacheable(value = CacheName.USER_BRANCHES, key = "#userId")
     public List<BranchResponse> getBranchesForUser(UUID userId) {
         UserEntity user = userRepository.findById(userId)
                 .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -118,11 +117,6 @@ public class BranchService {
     }
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "branches", key = "#businessId"),
-        @CacheEvict(value = "branch", key = "#branchId"),
-        @CacheEvict(value = "user-branches", allEntries = true)
-    })
     public BranchResponse updateBranch(UUID userId, UUID branchId, UUID businessId, UpdateBranchRequest request) {
         log.info("Updating branch {} for business {}", branchId, businessId);
         UserEntity actor = userRepository.findById(userId)
@@ -231,6 +225,9 @@ public class BranchService {
         activityLogService.logBranchUpdated(actor, branch.getBusiness(), saved, details);
 
         log.info("Branch {} updated. Changes: {}", branchId, changes.size());
+        cacheService.evict(CacheName.BRANCHES, businessId);
+        cacheService.evict(CacheName.BRANCH, branchId);
+        cacheService.evictAll(CacheName.USER_BRANCHES);
         return mapToResponse(saved);
     }
 
@@ -291,11 +288,6 @@ public class BranchService {
     }
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "branches", key = "#businessId"),
-        @CacheEvict(value = "branch", key = "#branchId"),
-        @CacheEvict(value = "user-branches", allEntries = true)
-    })
     public void deleteBranch(UUID userId, UUID branchId, UUID businessId) {
         log.info("Deleting branch {} for business {}", branchId, businessId);
         UserEntity actor = userRepository.findById(userId)
@@ -312,9 +304,12 @@ public class BranchService {
         activityLogService.logBranchDeleted(actor, branch.getBusiness(), branch.getName());
 
         branchRepository.delete(branch);
+        cacheService.evict(CacheName.BRANCHES, businessId);
+        cacheService.evict(CacheName.BRANCH, branchId);
+        cacheService.evictAll(CacheName.USER_BRANCHES);
     }
 
-    @Cacheable(value = "branch", key = "#branchId")
+    @Cacheable(value = CacheName.BRANCH, key = "#branchId")
     public BranchResponse getBranchById(UUID branchId) {
         BranchEntity branch = branchRepository.findById(branchId)
                 .orElseThrow(() -> new ResourceNotFoundException("Branch not found"));
diff --git a/src/main/java/com/orasa/backend/service/BranchServiceService.java b/src/main/java/com/orasa/backend/service/BranchServiceService.java
index d628859..2422796 100644
--- a/src/main/java/com/orasa/backend/service/BranchServiceService.java
+++ b/src/main/java/com/orasa/backend/service/BranchServiceService.java
@@ -3,7 +3,10 @@ package com.orasa.backend.service;
 import java.util.List;
 import java.util.UUID;
 
+import org.springframework.cache.annotation.Cacheable;
 import org.springframework.stereotype.Service;
+
+import com.orasa.backend.common.CacheName;
 import org.springframework.transaction.annotation.Transactional;
 
 import com.orasa.backend.domain.BranchEntity;
@@ -27,6 +30,7 @@ public class BranchServiceService {
     private final BranchServiceRepository branchServiceRepository;
     private final BranchRepository branchRepository;
     private final ServiceRepository serviceRepository;
+    private final CacheService cacheService;
 
     @Transactional
     public BranchServiceResponse assignServiceToBranch(UUID branchId, UUID businessId, AssignServiceToBranchRequest request) {
@@ -60,9 +64,11 @@ public class BranchServiceService {
                 .build();
 
         BranchServiceEntity saved = branchServiceRepository.save(branchService);
+        cacheService.evict(CacheName.BRANCH_SERVICES, branchId);
         return mapToResponse(saved);
     }
 
+    @Cacheable(value = CacheName.BRANCH_SERVICES, key = "#branchId")
     public List<BranchServiceResponse> getServicesByBranch(UUID branchId) {
         return branchServiceRepository.findByBranchId(branchId).stream()
                 .map(this::mapToResponse)
@@ -87,6 +93,7 @@ public class BranchServiceService {
         branchService.setActive(request.getActive());
 
         BranchServiceEntity saved = branchServiceRepository.save(branchService);
+        cacheService.evict(CacheName.BRANCH_SERVICES, branchService.getBranchId());
         return mapToResponse(saved);
     }
 
@@ -103,6 +110,7 @@ public class BranchServiceService {
         }
 
         branchServiceRepository.delete(branchService);
+        cacheService.evict(CacheName.BRANCH_SERVICES, branchService.getBranchId());
     }
 
     private BranchServiceResponse mapToResponse(BranchServiceEntity branchService) {
diff --git a/src/main/java/com/orasa/backend/service/BusinessService.java b/src/main/java/com/orasa/backend/service/BusinessService.java
index 1926caf..ddc4137 100644
--- a/src/main/java/com/orasa/backend/service/BusinessService.java
+++ b/src/main/java/com/orasa/backend/service/BusinessService.java
@@ -25,8 +25,8 @@ import org.springframework.security.core.Authentication;
 import org.springframework.security.core.context.SecurityContextHolder;
 
 
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.cache.annotation.Cacheable;
+import com.orasa.backend.common.CacheName;
 import com.orasa.backend.dto.activity.FieldChange;
 import lombok.RequiredArgsConstructor;
 import lombok.extern.slf4j.Slf4j;
@@ -44,6 +44,7 @@ public class BusinessService {
     private final UserRepository userRepository;
     private final SubscriptionService subscriptionService;
     private final ActivityLogService activityLogService;
+    private final CacheService cacheService;
     private final UserService userService;
 
     /**
@@ -103,7 +104,7 @@ public class BusinessService {
      * Gets a business by ID.
      */
     @Transactional
-    @Cacheable(value = "business", key = "#businessId")
+    @Cacheable(value = CacheName.BUSINESS, key = "#businessId")
     public BusinessResponse getBusinessById(UUID businessId) {
         BusinessEntity business = businessRepository.findById(businessId)
                 .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
@@ -114,7 +115,6 @@ public class BusinessService {
     }
 
     @Transactional
-    @CacheEvict(value = "business", key = "#businessId")
     public BusinessResponse updateBusiness(UUID businessId, UpdateBusinessRequest request) {
         BusinessEntity business = businessRepository.findById(businessId)
                 .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
@@ -133,6 +133,7 @@ public class BusinessService {
             activityLogService.logBusinessUpdated(actor, savedBusiness, FieldChange.toJson(changes));
         }
         
+        cacheService.evict(CacheName.BUSINESS, businessId);
         return mapToResponse(savedBusiness, null);
     }
 
diff --git a/src/main/java/com/orasa/backend/service/ReminderConfigService.java b/src/main/java/com/orasa/backend/service/ReminderConfigService.java
index 869b40a..78aacba 100644
--- a/src/main/java/com/orasa/backend/service/ReminderConfigService.java
+++ b/src/main/java/com/orasa/backend/service/ReminderConfigService.java
@@ -3,9 +3,10 @@ package com.orasa.backend.service;
 import java.util.List;
 import java.util.UUID;
 
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.cache.annotation.Cacheable;
 import org.springframework.stereotype.Service;
+
+import com.orasa.backend.common.CacheName;
 import org.springframework.transaction.annotation.Transactional;
 
 import com.orasa.backend.domain.BusinessReminderConfigEntity;
@@ -27,9 +28,9 @@ import lombok.extern.slf4j.Slf4j;
 public class ReminderConfigService {
 
     private final BusinessReminderConfigRepository reminderConfigRepository;
+    private final CacheService cacheService;
 
     @Transactional
-    @CacheEvict(value = "reminder-configs", key = "#businessId")
     public ReminderConfigResponse createConfig(UUID businessId, CreateReminderConfigRequest request) {
         log.info("SMS request: {}", request);
         List<BusinessReminderConfigEntity> existingConfigs = reminderConfigRepository.findByBusinessId(businessId);
@@ -48,11 +49,11 @@ public class ReminderConfigService {
                 .build();
 
         BusinessReminderConfigEntity saved = reminderConfigRepository.save(config);
+        cacheService.evict(CacheName.REMINDER_CONFIGS, businessId);
         return mapToResponse(saved);
     }
 
     @Transactional
-    @CacheEvict(value = "reminder-configs", key = "#businessId")
     public ReminderConfigResponse updateConfig(UUID configId, UUID businessId, UpdateReminderConfigRequest request) {
         BusinessReminderConfigEntity config = getConfigById(configId, businessId);
 
@@ -77,10 +78,11 @@ public class ReminderConfigService {
         }
 
         BusinessReminderConfigEntity saved = reminderConfigRepository.save(config);
+        cacheService.evict(CacheName.REMINDER_CONFIGS, businessId);
         return mapToResponse(saved);
     }
 
-    @Cacheable(value = "reminder-configs", key = "#businessId")
+    @Cacheable(value = CacheName.REMINDER_CONFIGS, key = "#businessId")
     public List<ReminderConfigResponse> getConfigsByBusiness(UUID businessId) {
         return reminderConfigRepository.findByBusinessId(businessId).stream()
                 .map(this::mapToResponse)
@@ -104,10 +106,10 @@ public class ReminderConfigService {
     }
 
     @Transactional
-    @CacheEvict(value = "reminder-configs", key = "#businessId")
     public void deleteConfig(UUID configId, UUID businessId) {
         BusinessReminderConfigEntity config = getConfigById(configId, businessId);
         reminderConfigRepository.delete(config);
+        cacheService.evict(CacheName.REMINDER_CONFIGS, businessId);
     }
 
     private BusinessReminderConfigEntity getConfigById(UUID configId, UUID businessId) {
diff --git a/src/main/java/com/orasa/backend/service/ServiceService.java b/src/main/java/com/orasa/backend/service/ServiceService.java
index ffd9111..5367814 100644
--- a/src/main/java/com/orasa/backend/service/ServiceService.java
+++ b/src/main/java/com/orasa/backend/service/ServiceService.java
@@ -5,10 +5,10 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.cache.annotation.Cacheable;
-import org.springframework.cache.annotation.Caching;
 import org.springframework.stereotype.Service;
+
+import com.orasa.backend.common.CacheName;
 import org.springframework.transaction.annotation.Transactional;
 
 import com.orasa.backend.domain.BusinessEntity;
@@ -42,12 +42,9 @@ public class ServiceService {
     private final BranchRepository branchRepository;
     private final BranchServiceRepository branchServiceRepository;
     private final ActivityLogService activityLogService;
+    private final CacheService cacheService;
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "services", key = "#businessId"),
-        @CacheEvict(value = "branches", key = "#businessId")
-    })
     public ServiceResponse createService(UUID actorUserId, UUID businessId, CreateServiceRequest request) {
         UserEntity actor = userRepository.findById(actorUserId)
                 .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -78,14 +75,12 @@ public class ServiceService {
 
         activityLogService.logServiceCreated(actor, business, saved.getName());
         
+        cacheService.evict(CacheName.SERVICES, businessId);
+        cacheService.evict(CacheName.BRANCHES, businessId);
         return mapToResponse(saved);
     }
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "services", key = "#businessId"),
-        @CacheEvict(value = "service", key = "#serviceId")
-    })
     public ServiceResponse updateService(UUID actorUserId, UUID serviceId, UUID businessId, UpdateServiceRequest request) {
         UserEntity actor = userRepository.findById(actorUserId)
                 .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -149,12 +144,15 @@ public class ServiceService {
             // Log service update with details
             String details = FieldChange.toJson(changes);
             activityLogService.logServiceUpdated(actor, business, serviceOffering.getName(), details);
+
+            cacheService.evict(CacheName.SERVICES, businessId);
+            cacheService.evict(CacheName.SERVICE, serviceId);
         }
 
         return mapToResponse(serviceOffering);
     }
 
-    @Cacheable(value = "services", key = "{#businessId, #branchId}")
+    @Cacheable(value = CacheName.SERVICES, key = "{#businessId, #branchId}")
     public List<ServiceResponse> getServicesByBusiness(UUID businessId, UUID branchId) {
         List<ServiceEntity> services;
         if (branchId != null) {
@@ -167,7 +165,7 @@ public class ServiceService {
                 .toList();
     }
 
-    @Cacheable(value = "service", key = "#serviceId")
+    @Cacheable(value = CacheName.SERVICE, key = "#serviceId")
     public ServiceResponse getServiceById(UUID serviceId) {
         ServiceEntity serviceOffering = serviceRepository.findById(serviceId)
                 .orElseThrow(() -> new ResourceNotFoundException("Service not found"));
@@ -176,11 +174,6 @@ public class ServiceService {
     }
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "services", key = "#businessId"),
-        @CacheEvict(value = "branches", key = "#businessId"),
-        @CacheEvict(value = "service", key = "#serviceId")
-    })
     public void deleteService(UUID actorUserId, UUID serviceId, UUID businessId) {
         UserEntity actor = userRepository.findById(actorUserId)
                 .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -201,6 +194,9 @@ public class ServiceService {
         branchServiceRepository.deleteAll(branchLinks);
 
         serviceRepository.delete(serviceOffering);
+        cacheService.evict(CacheName.SERVICES, businessId);
+        cacheService.evict(CacheName.BRANCHES, businessId);
+        cacheService.evict(CacheName.SERVICE, serviceId);
     }
 
     private ServiceResponse mapToResponse(ServiceEntity serviceOffering) {
diff --git a/src/main/java/com/orasa/backend/service/StaffService.java b/src/main/java/com/orasa/backend/service/StaffService.java
index 71b4bf9..0d346da 100644
--- a/src/main/java/com/orasa/backend/service/StaffService.java
+++ b/src/main/java/com/orasa/backend/service/StaffService.java
@@ -26,9 +26,9 @@ import com.orasa.backend.repository.BusinessRepository;
 import com.orasa.backend.repository.UserRepository;
 
 import lombok.RequiredArgsConstructor;
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.cache.annotation.Cacheable;
-import org.springframework.cache.annotation.Caching;
+
+import com.orasa.backend.common.CacheName;
 
 @Service
 @RequiredArgsConstructor
@@ -41,9 +41,9 @@ public class StaffService {
     private final PasswordEncoder passwordEncoder;
     private final ActivityLogService activityLogService;
     private final UserService userService;
+    private final CacheService cacheService;
 
     @Transactional
-    @CacheEvict(value = "business-staff", key = "#businessId")
     public StaffResponse createStaff(UUID actorUserId, UUID businessId, CreateStaffRequest request) {
         UserEntity actor = userRepository.findById(actorUserId)
                 .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -85,14 +85,11 @@ public class StaffService {
         // Log staff creation
         activityLogService.logStaffCreated(actor, business, saved.getUsername());
         
+        cacheService.evict(CacheName.BUSINESS_STAFF, businessId);
         return mapToResponse(saved);
     }
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "staff", key = "#staffId"),
-        @CacheEvict(value = "business-staff", key = "#businessId")
-    })
     public StaffResponse updateStaff(UUID actorUserId, UUID staffId, UUID businessId, UpdateStaffRequest request) {
         UserEntity actor = userRepository.findById(actorUserId)
                 .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -166,10 +163,12 @@ public class StaffService {
             activityLogService.logStaffUpdated(actor, staff.getBusiness(), staff.getUsername(), details);
         }
         
+        cacheService.evict(CacheName.STAFF, staffId);
+        cacheService.evict(CacheName.BUSINESS_STAFF, businessId);
         return mapToResponse(saved);
     }
 
-    @Cacheable(value = "business-staff", key = "#businessId")
+    @Cacheable(value = CacheName.BUSINESS_STAFF, key = "#businessId")
     public List<StaffResponse> getStaffByBusiness(UUID businessId) {
         return userRepository.findByBusinessId(businessId).stream()
                 .filter(user -> user.getRole() == UserRole.STAFF)
@@ -177,17 +176,13 @@ public class StaffService {
                 .toList();
     }
 
-    @Cacheable(value = "staff", key = "#staffId")
+    @Cacheable(value = CacheName.STAFF, key = "#staffId")
     public StaffResponse getStaffMember(UUID staffId, UUID businessId) {
         UserEntity staff = getStaffById(staffId, businessId);
         return mapToResponse(staff);
     }
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "staff", key = "#staffId"),
-        @CacheEvict(value = "business-staff", key = "#businessId")
-    })
     public void deleteStaff(UUID actorUserId, UUID staffId, UUID businessId) {
         UserEntity actor = userRepository.findById(actorUserId)
                 .orElseThrow(() -> new ResourceNotFoundException("User not found"));
@@ -201,6 +196,8 @@ public class StaffService {
         userService.evictAuthenticatedUser(staffId);
         
         userRepository.delete(staff);
+        cacheService.evict(CacheName.STAFF, staffId);
+        cacheService.evict(CacheName.BUSINESS_STAFF, businessId);
     }
 
 
diff --git a/src/main/java/com/orasa/backend/service/SubscriptionService.java b/src/main/java/com/orasa/backend/service/SubscriptionService.java
index d0ac5db..5732a72 100644
--- a/src/main/java/com/orasa/backend/service/SubscriptionService.java
+++ b/src/main/java/com/orasa/backend/service/SubscriptionService.java
@@ -19,19 +19,22 @@ import lombok.extern.slf4j.Slf4j;
 import org.redisson.api.RBlockingQueue;
 import org.redisson.api.RDelayedQueue;
 import org.redisson.api.RedissonClient;
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;
 
+import com.orasa.backend.common.CacheName;
+
 @Service
 @RequiredArgsConstructor
 @Transactional(readOnly = true)
 @Slf4j
 public class SubscriptionService {
 
+
     private final BusinessRepository businessRepository;
     private final RedissonClient redissonClient;
     private final Clock clock;
+    private final CacheService cacheService;
 
     @Transactional
     public boolean isSubscriptionActive(UUID businessId) {
@@ -125,7 +128,6 @@ public class SubscriptionService {
     ) {}
 
     @Transactional
-    @CacheEvict(value = "business", key = "#businessId")
     public void activateSubscription(UUID businessId) {
         BusinessEntity business = businessRepository.findById(businessId)
                 .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
@@ -147,12 +149,13 @@ public class SubscriptionService {
         businessRepository.save(business);
         log.info("Activated subscription for business {}", businessId);
 
+        evictBusinessCache(businessId);
+
         // Schedule next credit reset
         scheduleCreditReset(businessId, business.getNextCreditResetDate());
     }
 
     @Transactional
-    @CacheEvict(value = "business", key = "#businessId")
     public void cancelSubscription(UUID businessId) {
         BusinessEntity business = businessRepository.findById(businessId)
                 .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
@@ -163,10 +166,10 @@ public class SubscriptionService {
         
         businessRepository.save(business);
         log.info("Cancelled subscription for business {}", businessId);
+        evictBusinessCache(businessId);
     }
 
     @Transactional
-    @CacheEvict(value = "business", key = "#businessId")
     public void extendSubscription(UUID businessId, int months) {
         BusinessEntity business = businessRepository.findById(businessId)
                 .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
@@ -177,6 +180,7 @@ public class SubscriptionService {
                 business.setSubscriptionEndDate(business.getSubscriptionEndDate().plusMonths(months - 1));
                 businessRepository.save(business);
             }
+            evictBusinessCache(businessId);
             return;
         }
         
@@ -188,10 +192,10 @@ public class SubscriptionService {
         businessRepository.save(business);
         log.info("Extended subscription for business {} by {} months. New end date: {}", 
                 businessId, months, business.getSubscriptionEndDate());
+        evictBusinessCache(businessId);
     }
 
     @Transactional
-    @CacheEvict(value = "business", key = "#businessId")
     public void consumeSmsCredit(UUID businessId) {
         BusinessEntity business = businessRepository.findById(businessId)
                 .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
@@ -200,7 +204,6 @@ public class SubscriptionService {
     }
 
     @Transactional(noRollbackFor = SubscriptionExpiredException.class)
-    @CacheEvict(value = "business", key = "#business.id")
     public void consumeSmsCredit(BusinessEntity business) {
         // 1. Lazy Reset: Check if we moved into a new cycle since last check
         checkAndRefreshCredits(business);
@@ -215,10 +218,10 @@ public class SubscriptionService {
         }
         
         businessRepository.save(business);
+        evictBusinessCache(business.getId());
     }
 
     @Transactional
-    @CacheEvict(value = "business", key = "#business.id")
     public void checkAndRefreshCredits(BusinessEntity business) {
         // 1. Check for Expiry First
         if (handleExpiryCheck(business)) {
@@ -236,18 +239,28 @@ public class SubscriptionService {
             business.setFreeSmsCredits(100);
             
             // Advance reset date by 1 month
-            // Ensure we don't fall behind if multiple months passed (though rare if system is active)
             while (!business.getNextCreditResetDate().isAfter(OffsetDateTime.now(clock))) {
                  business.setNextCreditResetDate(business.getNextCreditResetDate().plusMonths(1));
             }
             
             businessRepository.save(business);
+            evictBusinessCache(business.getId());
             
             // Schedule the NEXT reset
             scheduleCreditReset(business.getId(), business.getNextCreditResetDate());
         }
     }
 
+    @Transactional
+    public void addPaidCredits(UUID businessId, int credits) {
+        BusinessEntity business = businessRepository.findById(businessId)
+                .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
+
+        business.setPaidSmsCredits(business.getPaidSmsCredits() + credits);
+        businessRepository.save(business);
+        evictBusinessCache(businessId);
+    }
+
     private boolean handleExpiryCheck(BusinessEntity business) {
         if (business.getSubscriptionStatus() == SubscriptionStatus.ACTIVE 
             && business.getSubscriptionEndDate() != null 
@@ -257,19 +270,14 @@ public class SubscriptionService {
             business.setSubscriptionStatus(SubscriptionStatus.EXPIRED);
             business.setFreeSmsCredits(0);
             businessRepository.save(business);
+            evictBusinessCache(business.getId());
             return true;
         }
         return false;
-        
     }
-    @Transactional
-    @CacheEvict(value = "business", key = "#businessId")
-    public void addPaidCredits(UUID businessId, int credits) {
-        BusinessEntity business = businessRepository.findById(businessId)
-                .orElseThrow(() -> new ResourceNotFoundException("Business not found"));
 
-        business.setPaidSmsCredits(business.getPaidSmsCredits() + credits);
-        businessRepository.save(business);
+    private void evictBusinessCache(UUID businessId) {
+        cacheService.evict(CacheName.BUSINESS, businessId);
     }
 
     private void scheduleCreditReset(UUID businessId, OffsetDateTime resetDate) {
@@ -279,7 +287,7 @@ public class SubscriptionService {
             RDelayedQueue<CreditResetTask> delayedQueue = redissonClient.getDelayedQueue(blockingQueue);
 
             long delay = Duration.between(OffsetDateTime.now(clock), resetDate).toMillis();
-            if (delay < 0) delay = 0; // If already passed, run immediately (or close to it)
+            if (delay < 0) delay = 0;
 
             delayedQueue.offer(new CreditResetTask(businessId, resetDate), delay, TimeUnit.MILLISECONDS);
             log.info("Scheduled credit reset for business {} at {}", businessId, resetDate);
diff --git a/src/main/java/com/orasa/backend/service/sms/SmsService.java b/src/main/java/com/orasa/backend/service/sms/SmsService.java
index 4abc5dc..a50b27f 100644
--- a/src/main/java/com/orasa/backend/service/sms/SmsService.java
+++ b/src/main/java/com/orasa/backend/service/sms/SmsService.java
@@ -16,9 +16,7 @@ import java.util.concurrent.TimeUnit;
 import org.redisson.api.RBlockingQueue;
 import org.redisson.api.RDelayedQueue;
 import org.redisson.api.RedissonClient;
-import org.springframework.cache.annotation.CacheEvict;
 import org.springframework.cache.annotation.Cacheable;
-import org.springframework.cache.annotation.Caching;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
 import org.springframework.stereotype.Service;
@@ -41,6 +39,8 @@ import com.orasa.backend.repository.SmsLogRepository;
 import com.orasa.backend.repository.ScheduledSmsTaskRepository;
 import com.orasa.backend.service.ReminderConfigService;
 import com.orasa.backend.service.SubscriptionService;
+import com.orasa.backend.service.CacheService;
+import com.orasa.backend.common.CacheName;
 import com.orasa.backend.common.SmsTaskStatus;
 import com.orasa.backend.domain.ScheduledSmsTaskEntity;
 import com.orasa.backend.exception.SubscriptionExpiredException;
@@ -64,6 +64,7 @@ public class SmsService {
     private final ScheduledSmsTaskRepository scheduledSmsTaskRepository;
     private final RedissonClient redissonClient;
     private final Clock clock;
+    private final CacheService cacheService;
 
     private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("MMM d, yyyy");
     private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("h:mm a");
@@ -167,10 +168,6 @@ public class SmsService {
     }
 
     @Transactional
-    @Caching(evict = {
-        @CacheEvict(value = "sms-logs", key = "#task.businessId"),
-        @CacheEvict(value = "analytics", allEntries = true)
-    })
     public void processScheduledTask(SmsReminderTask task) {
         UUID appointmentId = task.getAppointmentId();
         UUID scheduledTaskId = task.getScheduledTaskId();
@@ -277,14 +274,12 @@ public class SmsService {
         }
         
         scheduledSmsTaskRepository.save(scheduledTask);
+        cacheService.evict(CacheName.SMS_LOGS, task.getBusinessId());
+        cacheService.evictAll(CacheName.ANALYTICS);
     }
 
     @Transactional
     @RequiresActiveSubscription
-    @Caching(evict = {
-        @CacheEvict(value = "sms-logs", key = "#business.id"),
-        @CacheEvict(value = "analytics", allEntries = true)
-    })
     public SmsLogEntity sendSms(BusinessEntity business, SmsLogEntity smsLog) {
         subscriptionService.consumeSmsCredit(business);
 
@@ -295,10 +290,13 @@ public class SmsService {
         smsLog.setProviderResponse(result.rawResponse());
         smsLog.setErrorMessage(result.errorMessage());
 
-        return smsLogRepository.save(smsLog);
+        SmsLogEntity saved = smsLogRepository.save(smsLog);
+        cacheService.evict(CacheName.SMS_LOGS, business.getId());
+        cacheService.evictAll(CacheName.ANALYTICS);
+        return saved;
     }
 
-    @Cacheable(value = "sms-logs", key = "#businessId", condition = "#pageable.pageNumber == 0 && #branchId == null && #status == null && #startDate == null && #endDate == null")
+    @Cacheable(value = CacheName.SMS_LOGS, key = "#businessId", condition = "#pageable.pageNumber == 0 && #branchId == null && #status == null && #startDate == null && #endDate == null")
     public com.orasa.backend.dto.common.PageResponse<SmsLogResponse> getSmsLogs(
             UUID businessId,
             UUID branchId,
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   src/main/java/com/orasa/backend/config/AppConfig.java
	modified:   src/main/java/com/orasa/backend/config/CacheConfig.java
	modified:   src/main/java/com/orasa/backend/service/ActivityLogService.java
	modified:   src/main/java/com/orasa/backend/service/AnalyticsService.java
	modified:   src/main/java/com/orasa/backend/service/AppointmentService.java
	modified:   src/main/java/com/orasa/backend/service/BranchService.java
	modified:   src/main/java/com/orasa/backend/service/BranchServiceService.java
	modified:   src/main/java/com/orasa/backend/service/BusinessService.java
	modified:   src/main/java/com/orasa/backend/service/ReminderConfigService.java
	modified:   src/main/java/com/orasa/backend/service/ServiceService.java
	modified:   src/main/java/com/orasa/backend/service/StaffService.java
	modified:   src/main/java/com/orasa/backend/service/SubscriptionService.java
	modified:   src/main/java/com/orasa/backend/service/sms/SmsService.java

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	diff.txt
	src/main/java/com/orasa/backend/common/CacheName.java
	src/main/java/com/orasa/backend/service/CacheService.java

no changes added to commit (use "git add" and/or "git commit -a")
